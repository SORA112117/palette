//
//  GalleryViewModel.swift
//  palette
//
//  Created by Claude on 2025/08/14.
//

import Foundation
import SwiftUI
import Combine

// MARK: - ギャラリー画面ViewModel
@MainActor
class GalleryViewModel: ObservableObject {
    
    // MARK: - Published Properties
    @Published var palettes: [ColorPalette] = []
    @Published var filteredPalettes: [ColorPalette] = []
    @Published var searchText: String = ""
    @Published var selectedFilter: PaletteFilter = .all
    @Published var selectedSortOrder: PaletteSortOrder = .newestFirst
    @Published var isLoading = false
    @Published var selectedPalettes: Set<UUID> = []
    @Published var showingDeleteConfirmation = false
    @Published var showingTagFilter = false
    @Published var isSelectionMode = false
    @Published var statistics: PaletteStatistics?
    @Published var availableTags: [String] = []
    
    // MARK: - Grid Layout
    @Published var gridColumns: [GridItem] = [
        GridItem(.flexible(), spacing: 12),
        GridItem(.flexible(), spacing: 12)
    ]
    @Published var isGridView = true
    
    // MARK: - Services
    private let storageService = StorageService.shared
    private let hapticManager = HapticManager.shared
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Initialization
    init() {
        setupObservers()
        loadPalettes()
    }
    
    // MARK: - Setup
    
    private func setupObservers() {
        // 検索テキストの監視
        $searchText
            .debounce(for: .milliseconds(300), scheduler: RunLoop.main)
            .sink { [weak self] _ in
                self?.applyFilters()
            }
            .store(in: &cancellables)
        
        // フィルターと並び順の監視
        Publishers.CombineLatest($selectedFilter, $selectedSortOrder)
            .sink { [weak self] _, _ in
                self?.applyFilters()
            }
            .store(in: &cancellables)
        
        // StorageServiceのパレットリストを監視
        storageService.$savedPalettes
            .receive(on: RunLoop.main)
            .sink { [weak self] savedPalettes in
                self?.palettes = savedPalettes
                self?.updateAvailableTags()
                self?.applyFilters()
                self?.updateStatistics()
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Data Loading
    
    func loadPalettes() {
        isLoading = true
        
        Task {
            // 少し遅延を入れてローディング状態を表示
            try? await Task.sleep(nanoseconds: 300_000_000)
            
            await MainActor.run {
                self.storageService.loadAllPalettes()
                self.isLoading = false
            }
        }
    }
    
    func refreshPalettes() {
        loadPalettes()
        hapticManager.lightImpact()
    }
    
    // MARK: - Filtering and Sorting
    
    private func applyFilters() {
        var filtered = palettes
        
        // フィルター適用
        filtered = storageService.filterPalettes(by: selectedFilter)
        
        // 検索適用
        if !searchText.isEmpty {
            filtered = storageService.searchPalettes(query: searchText)
                .filter { palette in
                    switch selectedFilter {
                    case .all:
                        return true
                    case .favorites:
                        return storageService.favoritesPalettes.contains { $0.id == palette.id }
                    case .recent:
                        let oneWeekAgo = Date().addingTimeInterval(-7 * 24 * 60 * 60)
                        return palette.createdAt > oneWeekAgo
                    case .byTag(let tag):
                        return palette.tags.contains(tag)
                    }
                }
        }
        
        // ソート適用
        filtered = sortPalettes(filtered, by: selectedSortOrder)
        
        withAnimation(.easeInOut(duration: 0.3)) {
            filteredPalettes = filtered
        }
    }
    
    private func sortPalettes(_ palettes: [ColorPalette], by sortOrder: PaletteSortOrder) -> [ColorPalette] {
        switch sortOrder {
        case .newestFirst:
            return palettes.sorted { $0.createdAt > $1.createdAt }
        case .oldestFirst:
            return palettes.sorted { $0.createdAt < $1.createdAt }
        case .nameAscending:
            return palettes.sorted { 
                $0.autoGeneratedTitle.localizedStandardCompare($1.autoGeneratedTitle) == .orderedAscending
            }
        case .nameDescending:
            return palettes.sorted { 
                $0.autoGeneratedTitle.localizedStandardCompare($1.autoGeneratedTitle) == .orderedDescending
            }
        case .colorCount:
            return palettes.sorted { $0.colors.count > $1.colors.count }
        case .mostUsedColors:
            return palettes.sorted { 
                $0.colors.reduce(0) { $0 + $1.percentage } > $1.colors.reduce(0) { $0 + $1.percentage }
            }
        }
    }
    
    // MARK: - Palette Management
    
    func deletePalette(_ palette: ColorPalette) {
        Task {
            do {
                try await storageService.deletePalette(palette)
                hapticManager.mediumImpact()
            } catch {
                print("パレット削除エラー: \(error)")
                hapticManager.error()
            }
        }
    }
    
    func deleteSelectedPalettes() {
        Task {
            for paletteId in selectedPalettes {
                if let palette = palettes.first(where: { $0.id == paletteId }) {
                    try? await storageService.deletePalette(palette)
                }
            }
            selectedPalettes.removeAll()
            isSelectionMode = false
            hapticManager.mediumImpact()
        }
    }
    
    func toggleFavorite(_ palette: ColorPalette) {
        storageService.toggleFavorite(palette)
        hapticManager.colorSelection()
    }
    
    func duplicatePalette(_ palette: ColorPalette) {
        let duplicatedPalette = ColorPalette(
            sourceImageData: palette.sourceImageData,
            colors: palette.colors,
            title: "\(palette.autoGeneratedTitle) (コピー)",
            tags: palette.tags
        )
        
        Task {
            try? await storageService.savePalette(duplicatedPalette)
            hapticManager.success()
        }
    }
    
    // MARK: - Selection Mode
    
    func toggleSelectionMode() {
        isSelectionMode.toggle()
        if !isSelectionMode {
            selectedPalettes.removeAll()
        }
        hapticManager.selectionChanged()
    }
    
    func togglePaletteSelection(_ palette: ColorPalette) {
        if selectedPalettes.contains(palette.id) {
            selectedPalettes.remove(palette.id)
        } else {
            selectedPalettes.insert(palette.id)
        }
        hapticManager.lightImpact()
    }
    
    func selectAllPalettes() {
        selectedPalettes = Set(filteredPalettes.map { $0.id })
        hapticManager.selectionChanged()
    }
    
    func deselectAllPalettes() {
        selectedPalettes.removeAll()
        hapticManager.selectionChanged()
    }
    
    // MARK: - View Toggle
    
    func toggleViewStyle() {
        withAnimation(.easeInOut(duration: 0.3)) {
            isGridView.toggle()
            if isGridView {
                gridColumns = [
                    GridItem(.flexible(), spacing: 12),
                    GridItem(.flexible(), spacing: 12)
                ]
            } else {
                gridColumns = [GridItem(.flexible())]
            }
        }
        hapticManager.selectionChanged()
    }
    
    // MARK: - Statistics and Tags
    
    private func updateStatistics() {
        statistics = storageService.getPaletteStatistics()
    }
    
    private func updateAvailableTags() {
        let allTags = palettes.flatMap { $0.tags }
        availableTags = Array(Set(allTags)).sorted()
    }
    
    func filterByTag(_ tag: String) {
        selectedFilter = .byTag(tag)
        showingTagFilter = false
    }
    
    // MARK: - Export and Share
    
    func exportPalettes(_ palettes: [ColorPalette]) -> [Data] {
        return palettes.compactMap { storageService.exportPalette($0) }
    }
    
    func sharePalette(_ palette: ColorPalette) {
        guard let data = storageService.exportPalette(palette) else { return }
        
        // JSONファイルとして共有
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("\(palette.autoGeneratedTitle).json")
        
        do {
            try data.write(to: tempURL)
            NavigationRouter.shared.presentShareSheet(items: [tempURL])
        } catch {
            print("エクスポートエラー: \(error)")
        }
    }
    
    // MARK: - Search Suggestions
    
    var searchSuggestions: [String] {
        let suggestions = availableTags + ["自然", "鮮やか", "パステル", "モノトーン"]
        return Array(Set(suggestions)).filter { suggestion in
            suggestion.localizedCaseInsensitiveContains(searchText) && suggestion != searchText
        }.prefix(5).sorted()
    }
}

// MARK: - Supporting Types

enum PaletteSortOrder: CaseIterable {
    case newestFirst
    case oldestFirst
    case nameAscending
    case nameDescending
    case colorCount
    case mostUsedColors
    
    var displayName: String {
        switch self {
        case .newestFirst: return "新しい順"
        case .oldestFirst: return "古い順"
        case .nameAscending: return "名前昇順"
        case .nameDescending: return "名前降順"
        case .colorCount: return "色数順"
        case .mostUsedColors: return "使用率順"
        }
    }
    
    var icon: String {
        switch self {
        case .newestFirst: return "clock"
        case .oldestFirst: return "clock.badge.questionmark"
        case .nameAscending: return "textformat"
        case .nameDescending: return "textformat"
        case .colorCount: return "number.circle"
        case .mostUsedColors: return "chart.bar"
        }
    }
}